0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

                                        IRC SERVER
                                        
-------------------------------------------------------------------------------------------

                            Servers

- the backbone of the IRC, the component that links all other components together.
- clients connect to it in oder to talk to each other
- other servers connect to it to connect to connect to the general network

-------------------------------------------------------------------------------------------

                            Clients

- anything connected to a server but not a server
- 2 types of clients:

User Clients
- A program that provides a tesxt-based interface that we use to communicate with the IRC.
- Also known as "users"

Service Clients
- Not made for talking or used manually
- usually automated to provide a service to users (ex: statistics collection about users)

-------------------------------------------------------------------------------------------

                            Architecture

- an IRC network is a group of servers connected to each other
- organized as a spanning tree where each server is the central node of the network it sees (other servers that it is immediately connected to)
- All communication between clients goes through server - server communication

-------------------------------------------------------------------------------------------

                            Protocol Services

Client locator
- When a client connects to a server, it registers using a label (nickname) that servers and other clients can use to locate it.
- Servers keep track of labels in use.

Channel management
- A named group of users that all receive its messages.
- has a name and list of current members, and properties that can be manipulated by some of its members (ex: moderators)
- hosted on one or more servers

-------------------------------------------------------------------------------------------

                            IRC Concepts

One-to-one communication
- In order for clients to each other, all servers must be able to send a message in one direction along the entire spanning tree.
- the pathof a message is the shortest path between two servers.
- means that a message will only be seen by the servers that it goes through to be transmitted.

One-to-many communication
- to a channel:
    * like for one-to-one, a message sent to a channel must only be sent and seen by servers that support users on that channel
    * the message is sent only once to each local server hub, the server is then responsible for fanning it out to each sub servers
    * messages to a channel with multiple users travel like a one-to-one message.
- to a host / server mask:
    * provides a way to send a message to all users that correspond to a mask (all usernames that start with "tg")
    * messages themselves work in the same way as above.
- to a list:
    * the server receives a list of all users to whom it needs to deliver the message, then sends an individual message to each user
    * obviously a very inefficient method (ex: if there are duplicates in the list the message could be sent multiple times to a user)

One-to-all communication
- aka broadcast message, sent to all clients and/or servers
- can result in a massive amount of traffic as all servers / clients need to be reached
- used for some classes of messages so all servers have the same information
- Client-to-client:
    * there is no class of message that needs to be sent to every client
- Client-to-server:
    * any information that changes the state of the network (new channel, user joins or leaves a channel, etc) needs to be known by all servers, but this information is never handled by the client itself.
- Server-to-server:
    * much more common, used for any message that affects a user, channel or server. Most messages are this way.

-------------------------------------------------------------------------------------------

                            Architecture Problems / flaws

Scalability
- since all servers need to all have the same information, it is difficult to increase the scale without losing efficency

Reliability
- each link between two servers is a potential weak point in the whole network.

Network congestion
- A lot of traffic can cause the link between two servers to break, and need to be reconnected somewhere else, causing more traffic etc.
- to minimize this issue, servers purposefully do not reconnect too fast if disconnected, in order to reduce congestion

Privacy
- Since all servers need to have all the information, there is a concern for user privacy.

-------------------------------------------------------------------------------------------

###########################################################################################
                            
                            Channels

A named group of users that all receive messages sent to that channel.

-------------------------------------------------------------------------------------------

                            Channel rules

Namespace
- name is a string that begins with "#" , "&", "+" or "!" and that has <= 50 characters.
- case insensitive
- cannot contain a space, a comma "," , a ^G or a colon ":"

Channel scope
- a user can only become member of a channel if the server to which he is connected knows about that channel
- the list of servers that know about a channel must be shared by all servers with member users so that a message can reach all members
- channels that have a name starting with "&" are local to the server on which they are created
- if there is no channel mask:
    * the channel is known to all servers on the network
- if there is a channel mask:
    * the channel is only known to servers that have member users, and to its neighbors if the mask matches local and neighbor server names.
    * the area of a masked channel has to be contigous (all servers that are matched must be next to each other so that all users can be reached)

Channel Properties
- Each channel has its own properties that are defined by channel modes. These can be manipulated by channel members, and change the way that servers manage the channels.
- if a channel has a "+" prefix, it does not support channel modes. They are all unset.

Privileged members
- To keep the order on a channel, some members have more privileges. They can:
    * INVITE : invite a client if the channel is invite-only (+i mode)
    * KICK : eject a client from a channel
    * MODE : change the channel modes or member privileges
    * PRIVMSG : send messages to the channel (if mode +n, +m, +v)
    * TOPIC : change the channel topic if the mode is +t
- Channel Operators
    * aka chop or chanop, considered to own the channel
    * identified by "@" before their nickname (replies to WHO, NAMES, WHOIS)
    * do not exist in "+" channels (no modes)
- Channel Creators
    * if a user creates a "!" channel, he is its creator, and given operator status.
    * can toggle certain modes that operators cannot
    * the MODE command can distinguish operators from creators

-------------------------------------------------------------------------------------------

                            Channel Lifetime

Standard Channels
- prefix: "&", "#", "+"
- created implicitly when first user joins, and is destroyed when last user leaves it.
- a channel cannot be created if another channel of the same name exists.

Safe Channels
- prefix: "!"
- cannot be implicitly created, the user sends a JOIN request to the server, using "!" as channel identifier
- the user only chooses part of the channel name (short name) and the server adds 5 characters to the end in order to make it unique and invulnerable to network splits.
- is not destroyed when the last user leaves it

-------------------------------------------------------------------------------------------

                            User Commands

#Mandatory
NICK <nickname> - changes the client's nickname. Takes an argument, the new nickname.

USER <user> <mode> <unused> <realname> - used at the beginning of the connection to specify the username, hostname, real name and initial user modes of
        the connecting client. <realname> can contain spaces, so must be prefixed by a colon (:).

JOIN <channels> - makes the client join the channel(s). If the parameter is a list separated by commas (,), the client joins all channels in the list.
        Else, the client joins the given channel.

PRIVMSG <msgtarget> :<message> - sends the <message> to the <msgtarget> (a user or a channel)

OPER <username> <password> - gives the user <username> operator status if possible (if the user matches the criteria)

WHO [<name> ["o"]] - returns a list of users who match the name <name>. If the -o flag is given, only return the IRC operators that match the name.

WHOIS <nicknames> - returns information about the comma (,) separated list of nicks <nicknames>. If a single nickname is given, returns detailed information about them.

WHOWAS <nickname> [<count>] - returns information about a nickname that is no longer used (the client disconnected.) if the <count> argument is given:
        returns information about the last <count> times that the nickname has been used.

PART <channels> - causes a user to leave the channels in the comma (,) separated list of channels <channels>.

#Optional
INVITE <nickname> <channel> - invites the user <nickname> to join channel <channel>. If the channel has mode -i on, only a channel operator can invite someone else.

KICK <channel> <client> - removes client <client> from channel <channel>. Can only be done by a channel operator.

LIST [<channels>] - lists the channel on the server. If the <channels> parameter is given, lists all the channels of the topic <channels>.

NAMES [<channels>] - lists all the users on the server, grouped by channels (all users not on any channel are shown to be under channel "*"). If
        <channels> is given, lists all the users on the comma (,) separated list of channels <channels>.
    
TOPIC <channel> [<topic>] - returns the topic of channel <channel>. If <topic> is given, changes the topic of <channel> to it. If channel mode -t is on,
        only a channel operator can change the topic.

MODE <channel> {[+|-]|o|p|s|i|t|n|b|v} [<limit>] [<user>] [<ban mask>] - changes a mode of <channel>, must be done by a channel operator.
    a - toggle the anonymous channel flag. The sender of any message will be masked. Can only be toggled by the channel creator. Cannot be used on other channels. The WHOIS, WHO and NAMES commands must not reveal the users.
    i - toggle the invite-only channel flag - new members are only accepted if they match invite-list or if an operator invites them. Restricts the usage of INVITE command.
    m - toggle the moderated channel - only channel operators and voice privileged members can send messages.
    n - toggle the no messages to channel from clients on the outside - only members can send messages.
    q - toggle the quiet channel flag - for use by servers only, does not send new join, parts or nick changes messages. typically used to have a channel for the server to send notices relating to its operations.
    p - toggle the private channel flag - name of the channel cannot be acquired from the servers if not a member. Omitted from queries like WHOIS.
    s - toggle the secret channel flag - same as secret, server acts like the channel does not exist fir TOPIC, LIST, NAMES commands, but will correctly reply to MODES command. Not counted in LUSERS command.
    r - toggle the server reop channel flag - only on "!" channels, can only be toggled by creator. Takes an amount of time, and if there is no operator for longer than that, the channel reops some or all channel inhabitants.
    t - toggle the topic settable by channel operator only flag - restricts the usage of TOPIC command to operators.
    k - set/remove the channel key (password) - servers reject requests to join the channel unless the key is given. Key is given to members after a MODE query.
    l - set/remove the user limit to channel - when the limit is reached, servers forbid their local users from joining. Limit is given to members after a MODE query
    Access control:
    b - set/remove ban mask to keep users out - if a user tries to join, his user checks whether his addresses the ban mask and if so forbids him from joining unless he is also on an exception mask.
    e - set/remove an exception mask to override a ban mask
    if a user has been banned, he can be reinvited by an operator and rejoin. Cannot speak on the channel unless he is an operator or has voice privilege.
    I - set/remove an invitation mask to automatically override the invite-only flag - users whose addresses match the mask can join the channel without invitation.

MODE <nickname> {[+|-]|i|w|o|a|r}
    These modes usually affect:
    - how a user is seen by the other users
    - which messages / types of messages are sent to the user.
    Modes:
    a - The user is flagged as "away", instead user should use AWAY command.
    i - the user is marked as invisible, hides you if someone does a /WHO or /NAMES
    w - user receives wallops, which are messages sent to all users with -w turned on on a server.
    r - restricted user connection - can be turned on (a user de-ops themselves) but not turned off by a user
    o - operator flag, can be turned off but not on by a user

QUIT - disconnects the user from the server.

KILL <client> - forcibly removes a client <client> from the network. Can only be issued by an IRC operator.

DIE - Instructs the server to shut down. Can only be issued by an IRC operator.

HELP - displays a help file, usually created by the creators of the server, with useful information.

INFO [<target>] - displays information about the server <target>, or this server if no parameter is given.

ISON <nicknames> - returns which users in the comma (,) separated list <nicknames> is currently on the network, or an empty list if no one is on.

PASS <password> - sets a connection password (password to a nickname so the nickname is reserved.)

PING <server> - tests the presence of a connection, a PING message expects a PONG reply.

PONG <server> - replies to a PING message, to respond "I am still alive and the connection still works"

RULES - requests the server rules, if they have been defined in the server.

TIME [<server>] - returns the local time on this server, or on <server> if specified.

USERS [<server>] - returns a list of users and information about these users.

VERSION [<server>] - returns the version of the current server or of <server> if specified.

-------------------------------------------------------------------------------------------

                            Current Issues / Implementation

Tracking Recently Used Channels (aka Channel Delay)
- generally only applies to "#" channels
- when a network split occurs, servers need to keep track of which channels lost operators. These channels are put in a special state for a limited time:
    * They cannot cease to exist - if everyone leaves, it becomes unavailable and no one can join.
    * the channel can be available again if:
        # a user joins (the lost operator)
        # the time limit is reached, the channel is destroyed.
    * the time duration should be:
        # set according to the size of the network
        # set according to the usual duration of network splits
        # the same across all servers in the network

-------------------------------------------------------------------------------------------

Safe channels
- start with "!", then a given name, then a channel identifier provided by the server
- Channel identifier
    * the server uses the current time, converts it into a string of 5 characters using "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890" as a base.
- Channel Delay
    * follow the mechanism above, with a few differences:
        # servers keep track of ALL users (not just operators)
        # these channels never become unavailable, always possible to join them even if they are empty.
- Abuse window
    * since the identifier creating function is well known, we need to prevent someone from orchestrating a name collision:
        # a server keeps a list of current channel short names and identifiers that are about to be used to protect channel names if a network split occurs
        # can be solved by forbidding the use of the same short name altogether
- Server reop
    * if a channel has been opless for longer than the time set for a network split, and the "r" flag is set, the server follows the rules written on the doc (https://datatracker.ietf.org/doc/html/rfc2811 section 5.2.5)

-------------------------------------------------------------------------------------------


0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

                                                    SOCKETS

Sockets are the low level endpoints used to send and receive information across a network. They are used by protocols like HTTP (hyper text transfer protocol) or FTP (file transfer protocol).
Sockets are two way endpoints. You can send or receive information from any socket.

A socket is created with the C socket() call, returns an integer that is used to refer to it (like a fd).

Client socket:

Once the socket is created, we use the connect() call with an ip address and a port so that the socket knows what to connect to.
This returns a value that says it is successfull, and you can start sending / receiving information.


Server socket:

Once the socket is created, we use the bind() call to tell the socket where to listen for connections. We then use listen() to listen for connections, then use accept()
in order to get another socket to perform tasks on the client side. Finally we can use the send() or recv() functions to exchange data.


0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
                                                    
                                                    IRSSI commands

alt+1, alt+3, alt+5 to change windows
/window new for new window
/list -YES lists all channels and users
/nick displays your nick
/nick newnick changes your nick to newnick
/join joins a channel
/leave leaves a channel

0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

                                                    OSI Model

7 layers of communications between computers and machines. The 7 layers follow transmission protocols and each have a role in the transmission of data.

Layer 1: Physical Layer
    The lowest level of data transmission, converts bits received into radio waves, optical signals, etc... to send to another machine. Deals mainly with hardware
    and its limitations, such as maximum distance for a transmission, voltage changes, cable specifications, wave frequency, etc.
    Heavily used for Bluetooth, Ethernet and USB standards.

Layer 2: Data Link Layer
    - Provides basic node-to-node data transfer, defines the protocol to establish a connection between two physical devices. Basically manages the physical level.
    - Provides the means to detect and correct errors that occur in the physical layer.
    - This layer only applies to same-level nodes (two nodes connected on the same network will see their connection handled by this level, for network-network transmission, see higher layers.)
    - The data link layer receives requests from the network layer and fulfills them by issuing service requests to the physical layer.
    - Encapsulates the data received from the network layer into frames.
        * Frame: a data transmission unit, in the shape of a container for a network packet. Consists of a header followed by a packet. Is delimited by frame synchronization (a bit sequence that indicates the beginning and end of the data.)
    - Contains 2 sub-layers:
        * Medium access control (MAC) layer - controls how devices in a network gain access to the media. Also handles frame synchronization (determines the 
            start and end of each frame in the transmission bitstream.)
        * Logical Link control (LLC) layer - provides flow control, acknowledgment and error notification, along with contril and addressing of the data. Specifies 
            what to do in which situation.

Layer 3: Network Layer
    - Responsible for sending network packets from a source to a destination host via one or more networks. Responds to requests from the transport layer and issues requests to the data link layer.
    - Describes multiple network architectures (the Internet is an example of one.)
    - The communication at this layer is connectionless (the recipient of a packet does not send an acknowledgment to the sender like in higher layer communication. ex: UDP)
    - Assigns a unique address to all hosts in a network (ex: IP addresses on the Internet)
    - Sends the data between network through special hosts called gateways or routers.
    
Layer 4: Transport Layer
    - Delivers data to the appropriate application process on the host computer.
    - Provides protocols for connection-oriented communication (a communication is established before any data is sent, by having a "test" message sent. ex: TCP)
    - Error checking, to account for possible errors during the network layer protocols, error detection codes are created, and a sendre can be notified if something went wrong.
    - Controls the flow of data from the sender to the receiver (to prevent the sender from sending more than the receiver can handle)
    - Handles the contol of bandwith consumption (using congestion avoidance)
    - Multiplexing, or the idea that a node in a network can have multiple endpoints (ports) to access multiple network services at once.
    - Forms data segments that will be sent to the network layer, adds source and destination port numbers in the data header.
    - UDP and TCP are examples of transport layer protocols.
    - Does not know or try to know of the inside of the data packets, only determines where and how to forward them.

Layer 5: Session Layer
    - Controls the connections between computers. Establishes, maintains and closes the connection as needed.
    - An example of a session layer protocol is a connection recovery protocol, which reconnects two devices that have been disconnected.
    - Receives requests from the Presentation layer and relays them to the transport layer.
    - An example of this layer in action is in live tv programs or video conferencing, where the video stream and the audio stream must match perfectly.

Layer 6: Presentation Layer
    - Receives requests from the application layer and transmits them to the session layer through a unique presentation service access point (PSAP)
    - Makes sure that the information sent out by one system is readable by the receiver system. On the sender system, it will convert the data to the standard transmittable format.
        On the receiver it will translate, format, and deliver the information to be processed or displayed.
    - Some applications/protocols (like HTTP) do not differenciate between presentation and application layer, the tasks of the two are done at the same point in the transmission.
    - Up until here, the data retains its structure and presentation, but the protocols in this layer will make it understandable by other layers further down.
    - This is also usually where encryption and decryption are done.

Layer 7: Application Layer
    - Interface responsible for communicating with user-facing applications, what the user actually sees.
    - Sends the requests of the user to the underlying layers and protocols.

0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

                                                TCP / IP Model


Developped to have an efficient way to transmit data from one system to another on the Internet, this protocol has found that it is much safer to deconstruct a message into packets
rather than trying to send all of it at once. Although that might be a faster way to send data, all it takes is one issue for the whole transmission to be lost.
The packets are then reassembled once they have reached their destination, into the full message that they were to begin with. This allows different packets to take the
best path from one machine to another based on traffic congestion, error feedback etc. The different steps of communication are split into layers, and each layer serves
a specific purpose in the overall transmission process. This system is a way of standardizing the transmission of data so that each provider does not have to implement
their own transmission standard. The 4 layers are:

Layer 1: Application Layer
    - The application with which the user interacts, used to develop network-based applications.
    - provides services like naming network devices, formatting text, emails, file transfer, etc.
    - handles errors and message recovery if needed
    - uses protocols like: HTTP (formatting and transmission of hypertext and hypermedia), FTP (file transfer), DNS (naming system for devices in a network, translation of domain names to IP addresses.)

Layer 2: Transport Layer
    - Provides a reliable connection between two computers. Deconstructs the data into data packets, acknowledges data received from the other device and ensures that the other device
        acknowledges data received.
    - uses protocols like: TCP (reliable connection-oriented protocol, establishes a connection, divides byte streams into segments and assigns a sequence number to each segment so
        they can be reassembled into the correct order once delivered to the recipient. The recipient then sends an acknowledgment back to the sender.), UDP (a message-oriented protocol
            that provides a simple though unreliable and connectionless service. Used to transmit small amounts of data where speed of transmission is more important than accuracy.).

Layer 3: Internet/Network Layer
    - Controls the movement of packets across a network. Routes each data packet to the best way to reach the destination, independently of each other, to use the optimal route.
    - Reassembles the out-of-order packets once they have reached their destination, and handles error checking and remedial.
    - uses protocols like: IP (connectionless and unreliable protocol, transports datagrams across multiple nodes (routes)).

Layer 4: Host-to-Network Layer/Datalink
    - Manages the physical parts of sending the data, along with the pysical aspects of its reception (ethernet cable, router, etc)
    - Defines how bits are to be encoded into optical or electrical pulses.
    - Accepts IP packets and turns them into frames, handle frame synchronization.
    - States the transmission mode (simplex, half duplex, full duplex) and the topology of the network.
    - uses protocols like: Ethernet, Frame Relay, Token ring, ATM


                                                Transmission modes
                                            
Simplex mode:
    - the communication is unidirectional. Only one of the devices can transmit, the other can only receive. That way the entirety of the channel capacity can be used in one direction.
        ex: a keyboard sends information to a computer, without the need for information going the other way.

Half-duplex mode:
    - both devices can send and receive, but not at the same time. if one is sending, the other can only receive. like in simplex mode, the entirety of the channel capacity can be in use.
        ex: walkie-talkies
    
Full-duplex mode:
    - both devices can send and receive at any time. There are two ways to do this: either the link has two separate transmission paths, one for sending and one for receiving, or 
        the channel capacity is shared between the two.
        ex: telephone line

0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

                                                Ports and IP Addresses

On a TCP/IP network, each device must have a unique IP address to communicate with others. However each device must be able to run multiple
applications/processes at once, and for that a device has multiple ports. As an IP address identifies the computer on the network, a port identifies
the application running on that computer. Just like an apartment block has one street address for all the apartments (IP address), each of them has a number (port).

Ports
    - Ports use 16-bit numbers, and can therefore range from 0 to 65535.
    - Ports 0-1023 are allocated to server services by default. Web servers normally use port 80 and SMTP servers use 25.
    - Ports 1024-49151 are registered ports. They can be registered for services by the IANA and are semi-reserved.
    - Ports 49152-65535 are client program ports. Any user is free to use them in their program. These ports are ephemeral ports.
    - Ports are handled at the transport layer of the TCP/IP model, as part of the header that precedes the data packet.
    - FTP (File Transfer Protocol) uses: port tcp/20 to send data, port tcp/21 is used for the control channel.
    - Mail servers (usually use SMTP) on port tcp/25.
    - DNS (Domain Name Servers) usually use udp/53 for queries to change domain names into IP addresses but sometimes use port tcp/53 for zone transfers.
    - HTTP (Hyper Text Transfer Protocol) uses tcp/80.
    - HTTPS (Hyper Text Transfer Protocol Secure) uses tcp/443 to encrypt a HTTP pages.

TCP Sockets
    - A combination of an IP address and a port, each end of a connection between two devices will have a socket.
    - A computer connected to Google.com would be: IP(computer) + port 60200 <-------------> IP(Google) + port 80 (standard port)
    - Another tab on the same computer to Yahoo.com would be: IP(computer) + port 60401 <----------> IP(Yahoo) + port 80.
    - Your: computer IP + port number = your client computer socket. The Google IP + port 80 = the destination socket on the Google server.

IP Addresses
    - IP addresses are handled at the networking layer of the TCP/IP model, as part of the tail info of the data packet.
    - TCP/IP supports TCP ports and UDP ports.
    - TCP has its own 65535 ports and UDP has its own 65535 ports. They are not shared between them.


0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

                                                    Poll

Event: a significant change in state (a car being bought goes from "for sale" to "sold"). This event change is made known to other
functions and programs that do certain things based on the event.

int poll(struct pollfd *ufds, unsigned int nfds, int timeout);

This system call instructs a program to wait for read/write calls from the given document descriptors. Similar to select().
Poll takes 3 arguments:
    - ufds is an array that has one element for each document descriptor. The elements are pollfd structures:
        * struct pollfd {
            int     fd;     //File descriptor
            short   events; //Expected events, what the program is checking for
            short   revents; //Actual returned events
        };
    - nfds is an unsigned int, represents the size of the fd array.
    - timeout is an int that represents the max amount of time that poll should wait before closing.

0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

                                                    Subject Functions

int socket(int domain, int type, int protocol);
    - creates an endpoint for communication, returns an int (like a fd) that can be used to access it. This fd will be the lowest numbered fd not currently in use.
    - "domain" is the communication domain. This will refer to the protocol family that we want to use (ex: AF_INET for IPv4)
    - "type" is the type that we want to give to the socket. (ex: SOCK_STREAM for a two-way, connection based byte stream like TCP)
    - "protocol" is the protocol to be used by the socket (most type families have only one protocol so we set it to 0. ex: SOCK_STREAM only uses TCP)


int setsockopt(int socket, int level, int option_name, const void *option_value, socklen_t option_len);
    - sets the option "opt_name" at the level "level", to the value "option_value" on the socket "socket". Usually:
        setsockopt(fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt)); //here opt is an int equal to 1.
        This allows the socket to reuse addresses and ports. socklen_t in an unsigned int of size 32 max.

int getsockname(int s, struct sockaddr *name, socklen_t *namelen);
    - returns the name of socket "s" into "name". "namelen" must be initialized to the size of the memory pointed to by name.
    It then gets filled with the size of the name upon return.
    - struct sockaddr {
        sa_family_t     sa_family;      //unsigned int, the address family
        char            sa_data[14];    //actual address information
    }

struct protoent *getprotobyname(const char *name);
    - returns a protoent structure for the entry in the database that has the protocol name "name". A connection is opened if necessary.
    - struct protoent {
        char    *p_name;        //official protocol name
        char    **p_aliases;    //alias list (other names for the protocol)
        int     p_proto;        // protocol number
    }

struct hostent *gethostbyname(const char *name);
    - returns a structure hostent for the given host "name". "name" can be either a hostname or an IPv4 address in standard dot
    notation.
    - struct hostent {
        char    *h_name;        //official name of the host
        char    **h_aliases;    //list of the aliases, an array of pointers, the array ends with NULL.
        int     h_addrtype;     //address type of the host
        int     h_length;       //length of the address of the host
        char    **h_addr_list;  //list of pointers to network addresses for the host, ending also in NULL.
    }

int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);
    - "node" is an Internet host, and "service" is a service. Given those, returns one or more addrinfo structures that each contain an Internet address.
    - Combines the functionality of gethostbyname and getservbyname.
    - struct addrinfo {
        int             ai_flags;       //additional option ai_flags
        int             ai_family;      //address family for the returned addresses. ex: AF_INET.
        int             ai_socktype;    //preferred socket type, ex: SOCK_STREAM. 0 instead means any type.
        int             ai_protocol;    //protocol for returned socket addresses. 0 means any protocol can be used.
        socklen_t       ai_addrlen;     //length of the socket address in bytes.
        struct sockaddr *ai_addr;       //pointer to the socket address
        char            *ai_canonname;  //if ai_flags contains AI_CANNONNAME, points to the official name of the host.
        struct addrinfo *ai_next;       //next item in the linked list of addrinfo structures returned (like node *next).
    }

void freeaddrinfo(struct addrinfo *res);
    - frees the memory allocated for the linked list res in getaddrinfo.

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
    - the socket() call creates a socket but it has no address bound to it. Bind() assigns the address "addr" to the socket "sockfd".
    "addrlen" is the size in bytes of the address structure "addr". You basically assign a name to a socket.

int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
    - connects the socket "sockfd" to the address "addr". "addrlen: is the size of addr. Usually used by the client to connect to the server address.

int listen(int sockfd, int backlog);
    - marks the socket "sockfd" as a passive socket. That means a socket that will be used to accept connections using accept().
    - "backlog" is the max length of the pending connections queue. If a client tries to connect while the queue is full, it will receive an error / the connection will be ignored.

int accept(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict addrlen);
    - used for connection-based socket types (ex: SOCK_STREAM). Finds the first pending connection in the queue from listen(), and creates a socket with it,
    returning a file descriptor to it. The orinial socket "sockfd" is not affected by this call.
    - "sockfd" is a socket created by socket(), bound to an address with bind() and listens for connections using listen().
    - "addr" is a pointer to an address that will be filled in with the address of the new socket. "addrlen" is the size of that address. Can both be NULL if the server
    does not need the client's information.
    - if the queue is empty, accept() blocks the caller until a connection happens unless the socket is nonblocking (option set upon creation)

These functions handle conversion for byte orders in different communicating systems:
- uint16_t htons(uint16_t hostshort);     //converts from host byte order to network byte order.
- uint32_t htonl(uint32_t hostlong);      //converts from host byte order to network byte order.
- uint16_t ntohs(uint16_t netshort);      //converts from network byte order to host byte order.
- uint32_t ntohl(uint32_t netlong);       //converts from network byte order to host byte order.


in_addr_t inet_addr(const char *cp);
    - converts the Internet host address "cp" from IPv4 numbers-and-dots notation into network byte order.
    - typedef uint32_t  in_addr_t;

char *inet_ntoa(struct in_addr in);
    - converts the Internet host address "in" from network byte order to IPv4 dotted-decimal notation
    - struct in_addr {
        in_addr_t   s_addr;     //address
    }

ssize_t send(int sockfd, const void *buf, size_t len, int flags);
    - can only be used when socket "sockfd" is in a connected state. Sends the info in "buf" of size "len" to the socket "sockfd".
    - similar to write() but can add flags into "flags".
    - returns the number of bytes sent.

ssize_t recv(int sockfd, void *buf, size_t len, int flags);
    - used to receive a message from socket "sockfd". The message is stored into "buf" for the length "len".
    - similar to read() but can add flags into "flags".
    - returns the number of bytes received.

off_t lseek(int fd, off_t offset, int whence);
    - repositions the file offset of the open fd "fd" to the argument "offset" according to the directive "whence" which is:
        * SEEK_SET: the offset is set to "offset" bytes.
        * SEEK_CUR: the offset is set to its current location + "offset" bytes.
        * SEEK_END: the offset is set to the size of the file + "offset" bytes.
    - can be set to beyond the end of the file, and write there.
    - off_t is a signed integer

int fstat(int fd, struct stat *buf);
    - gets information about a file into "buf" (like stat()) but from a file descriptor "fd".
    - struct stat {
        dev_t           st_dev;     //unsigned long, ID of device containing file
        ino_t           st_ino;     //unsigned long, inode number
        mode_t          st_mode;    //unsigned long, macros to check the file type
        nlink_t         st_nlink;   //unsigned long, number of hard links
        uid_t           st_uid;     //int, user ID of owner
        gid_t           st_gid;     //uid_t, group ID of owner
        dev_t           st_rdev;    //unsigned long, device ID (if special file)
        off_t           st_size;    //long, total size of the file in bytes
        blksize_t       st_blksize; //long, preferred blocksize for file system I/O
        blkcnt_t        st_blocks;  //long, number of 512B blocks allocated
        time_t          st_atime;   //long, time of last access
        time_t          st_mtime;   //long, time of last modification
        time_t          st_ctime;   //long, time of last status change
    }

int fcntl(int fd, int cmd, ... /* arg */ );
    - performs an operation specified by "command" on file descriptor "fd". The function can, depending on "cmd", take a third argument, usually an int.
    - command examples are:
        * F_DUPFD (followed by an int) - duplicate the file descriptor into a new one.
        * F_GETFD (followed by void) - returns the file descriptor flags of fd.

int poll(struct pollfd *fds, nfds_t nfds, int timeout);
    - see above (line 415)